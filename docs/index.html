<html>
<head>
<title>Primer</title>
<style>
	body {
		margin: 40px;
		font-family: Geneva, Verdana;
		line-height: 140%;
	}
	pre {
		font-weight: bold;
		font-name: monospace;
		line-height: 140%;
		color: brown;
		font-size: 12pt;
		margin-left: 30px;
	}
	a {
		text-decoration: none;
		color: blue;
	}
	a:hover {
		background: blue;
		color: white;
	}
	h2 {
		margin-top: 40px;
	}
	span.sig {
		font-family: courier new;
		font-weight: bold;
	}
	li {
		margin: 10px;
	}
	li span.example {
		color: brown;
		font-weight: bold;
		font-family: monospace;
		font-size: 12pt;
	}
	li span.output {
		color: blue;
		font-weight: bold;
		font-family: monospace;
		font-size: 12pt;
	}
</style>
</head>
<body>
<h1>Primer</h1>
<p>
Primer is a little programming language in the early stages of development.
Downloads will be available soon. If you have any comments, please
<a href="mailto:philip.armitage@gmail.com">email</a> me.
</p>

<h2>Quick Start</h2>
<p>
To get started, unpack the archive somewhere on your PATH and
create the environment variable PRIMER_LIBRARY_PATH which should point to
StandardLibrary.pri.
</p>
<p>
The keyword <strong>def</strong> interns a new symbol and binds it to an
expression. In the example below we define a function with the
<strong>lambda</strong> keyword and bind it to the symbol Double.
A function implicitly returns the value of its last expression.
The <strong>Show</strong> function is provided by the runtime.
</p>
<pre>
def Double = lambda (x)
    2 * x
end

Show(Double(2))
</pre>
<p>
To run this, save it as Double.pri and at the shell enter:
</p>
<pre>
$ primer Double.pri
</pre>
<p>
Primer is dynamically typed and supports integers, floats, strings,
booleans and the value <strong>nil</strong> which represents nothing.
Bindings are immutable and lexically scoped.
</p>
<pre>
def pi = 3.14
Show(Double(pi))
</pre>
<p>
Conditional logic is handled by the if statement which has an optional else clause
and can be nested.
</p>
<pre>
def Rating = lambda (score)
    if (score > 90)
        "Well done!
    else
        "Try harder!"
    end
end
</pre>
<p>
Lists can contain values of any type, in any combination and can be
nested. They can be constructed either literally or by using
<strong>List</strong> and <strong>Cons</strong> and concatenated
using the <strong>++</strong> operator.
</p>
<pre>
def nums = [1, 2.2, 3, false, Double]
nums ++ List(true) ++ [5,[6,7,8]] ++ Cons(Cons([0,1], [2,3,4]), [5,[6,7,8]])
</pre>
<p>
You can use higher order and anonymous functions.
</p>
<pre>
def SumWithFun = lambda (fn, x, y)
    fn(x) + fn(y)
end

SumWithFun(Double, 4, 5)
SumWithFun(lambda (x) x * 2 end, nums)
</pre>

<h2>Function Reference</h2>

<ul>
<li>
	<span class="sig">All(fn, l)</span>
	- return true if all elements in list l pass the predicate function fn.
	<pre>All(Even, [3,4,5,6]) <span class="output">=> false</span></pre>
</li>

<li>
	<span class="sig">Any(fn, l)</span>
	- return true if any elements in list l pass the predicate function fn.
	<pre>Any(Even, [3,4,5,6]) <span class="output">=> true</span></pre>
</li>

<li>
	<span class="sig">Bool(z)</span>
	- returns true if z is of type boolean, otherwise returns false.
	<pre>Bool(false) <span class="output">=> true</span></pre>
</li>

<li>
	<span class="sig">Cons(l, e)</span>
	- construct a new list with element e prepended onto list l.
	<pre>Cons([3,4,5,6], 2) <span class="output">=> [2,3,4,5,6]</span></pre>
</li>

<li>
	<span class="sig">Drop(n, l)</span>
	- drop n items from the front of list l.
	<pre>Drop(3, [1,2,3,4,5]) <span class="output">=> [4,5]</span></pre>
</li>

<li>
	<span class="sig">DropWhile(fn, l)</span>
	- drop items from the head of list l until predicate function fn fails.
	<pre>DropWhile(Even, [2,4,6,7,8,9,10]) <span class="output">=> [7,8,9,10]</span></pre>
</li>

<li>
	<span class="sig">Empty(l)</span>
	- returns true if list l contains no elements.
	<pre>Empty([]) <span class="output">=> true</span></pre>
</li>

<li>
	<span class="sig">Even(z)</span>
	- returns true if z is an even number.
	<pre>Even(3) <span class="output">=> false</span></pre>
</li>

<li>
	<span class="sig">Find(x, l)</span>
	- returns x if the list l contains x, otherwise return nil.
	<pre>Find(2, [3,4,5,6]) <span class="output">=> nil</span></pre>
</li>

<li>
	<span class="sig">Filter(fn, l)</span>
	- returns a list containing the elements of l which satisfy predicate function fn.
	<pre>Filter(Odd, [1,2,3,4,5,6]) <span class="output">=> [1,3,5]</span></pre>
</li>

<li>
	<span class="sig">Float(z)</span>
	- returns true if z is of type float, otherwise returns false.
	<pre>Float(93.755) <span class="output">=> true</span></pre>
</li>

<li>
	<span class="sig">FoldL(fn, z, l)</span>
	- recursively combine list l using the binary function fn; combining z with the first element.
	<ul>
		<li>
			<span class="example">
				FoldL(AddAndDouble, 0, [1,2,3,4,5])
			</span>
			<span class="output">=> 30</span>
		</li>
	</ul>
</li>

<li>
	<span class="sig">FoldR(fn, z, l)</span>
	- recursively combine list l using the binary function fn; combining z with the last element.
	<ul>
		<li>
			<span class="example">
				FoldR(AddAndDouble, 0, [1,2,3,4,5])
			</span>	
			<span class="output">=> 15</span>
		</li>
	</ul>
</li>

<li>
	<span class="sig">Head(l)</span>
	- return the first element of a list.
	<pre>Head([3,4,5,6]) <span class="output">=> 3</span></pre>
</li>

<li>
	<span class="sig">Integer(z)</span>
	- returns true if z is of type integer, otherwise returns false.
	<pre>Integer(55) <span class="output">=> true</span></pre>
</li>

<li>
	<span class="sig">Last(l)</span>
	- return the last element of list l.
	<pre>Last([1,2,3,4,5]) <span class="output">=> 5</span></pre>
</li>

<li>
	<span class="sig">Length(l)</span>
	- return the length of list l.
	<pre>Length([1,2,3,4,5]) <span class="output">=> 5</span></pre>
</li>

<li>
	<span class="sig">List(x)</span>
	- return a new list containing x as its only member.
	<pre>List(4.55) <span class="output">=> [4.55]</span></pre>
</li>

<li>
	<span class="sig">Map(fn, l)</span>
	- applies function fn to each element of list l returning the result as a list.
	</p>
	<pre>Map(lambda (x) x * 2 end, [1,2,3,4,5]) <span class="output">=> [2,4,6,8,10]</span></pre>
</li>

<li>
	<span class="sig">Max(l)</span>
	- returns the largest numeric value from list l.
	<pre>Max([4,1,3,8,1,3,7]) <span class="output">=> 8</span></pre>
</li>

<li>
	<span class="sig">Min(l)</span>
	- returns the smallest numeric value from list l.
	<pre>Min([4,1,3,8,1,3,7]) <span class="output">=> 1</span></pre>
</li>

<li>
	<span class="sig">Nth(l, n)</span>
	- return the element in position n from list l. The index is 0 based.
	<pre>Nth([1,2,3,4,5], 3) <span class="output">=> 4</span></pre>
</li>

<li>
	<span class="sig">Odd(z)</span>
	- returns true if z is an odd number.
	<pre>Odd(3) <span class="output">=> true</span></pre>
</li>

<li>
	<span class="sig">Product(l)</span>
	- return the product of the values in list l.
	<pre>Product([1,2,3,4,5]) <span class="output">=> 120</span></pre>
</li>

<li>
	<span class="sig">Reverse(l)</span>
	- return a new list containing the items of list l but in reverse order.
	<pre>Reverse([1,2,3,4,5]) <span class="output">=> [5,4,3,2,1]</span></pre>
</li>

<li>
	<span class="sig">Show(z)</span>
	- display z to standard output.
	<pre>Show([3,4,5,6]) <span class="output">=> [3,4,5,6]</span></pre>
</li>

<li>
	<span class="sig">Sort(l)</span>
	- sort the elements of list l into ascending order.
	<ul>
		<li>
			<span class="example">
				Sort([99,96,91,92,94,98,93])
			</span>
			<span class="output">=> [91,92,93,94,96,98,99]</span>
		</li>
		<li>
			<span class="example">
				Sort("qwertyuiopasdfghjklzxcvbnm")
			</span>
			<span class="output">=> [a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z]</span>
		</li>
	</ul>
</li>

<li>
	<span class="sig">Sum(l)</span>
	- return the sum of the values in list l.
	<pre>Sum([1,2,3,4,5]) <span class="output">=> 15</span></pre>
</li>

<li>
	<span class="sig">Tail(l)</span>
	- return the tail of a list.
	<pre>Tail([3,4,5,6]) <span class="output">=> [4,5,6]</span></pre>
</li>

<li>
	<span class="sig">Take(z, l)</span>
	- take z items from the front of list l.
	<pre>Take(3, [1,2,3,4,5]) <span class="output">=> [1,2,3]</span></pre>
</li>

<li>
	<span class="sig">TakeWhile(fn, l)</span>
	- take items from the head of list l until predicate function fn fails.
	<pre>TakeWhile(Even, [2,4,6,7,8,9,10]) <span class="output">=> [2,4,6]</span></pre>
</li>

<li>
	<span class="sig">Type(z)</span>
	- returns the integral type code of object z.
	<pre>Type(3) <span class="output">=> 1</span></pre>
</li>
</ul>
</body>
</html>