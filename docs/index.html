<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html> 
<head> 

<title>Primer</title>
<meta name="google-site-verification" content="vgeoiUGsO_K7Rc1xaw97CHqm_qZ8WtGiPZbN7ZkroEY" />
<style>
html {
background: #c1c1c1;
color: #222;
}

div#content {
background: white;
font-family: verdana, "trebuchet ms", "Helvetica Neue", Helvetica, Arial, sans-serif;
-moz-border-radius: 1.5em;
-webkit-border-radius: 1.5em;
border-radius: 1.5em;
line-height: 140%;
width: 900px;
margin: 20px auto;
padding: 30px;
}

pre {
font-family: monospace;
background: #f1f1f1;
border-left: 2px solid black;
margin-right: 10px;
margin-left: 13px;
padding: 3px 0 3px 12px;
}

h1 {
font-size: 18pt;
}

h2 {
font-size: 14pt;
margin-top: 40px;
}

div.quote {
padding: 5px 20px 5px 20px;
border: 1px dashed black;
font-style: italic;
text-align: justify;
}

a {
text-decoration: none;
color: blue;
}

a:hover {
background: blue;
color: white;
}
</style> 
</head> 
<body>
<div id="content">

<h1>An introduction to Functional Programming with Primer</h1>
<hr/>

<p>
  Primer is a simple language designed to introduce the basics of
  functional programming. It can be learnt in an afternoon and the
  knowledge you'll gain is transferable to other functional languages.
</p>

<h2>Download</h2>
  
<p>
The language described on this page is mostly complete and a prototype
interpreter is under development. It will be
released under an open source license when it's ready. If you have
any comments or questions in the meantime then please feel free to
<a href="mailto:philip.armitage@gmail.com">email me</a>.
</p>

<h2>What is functional programming?</h2>

<p>
  Functional programming is a way of writing programs without relying
  on the mutation of state. The result is that a functional
  program can be thought of as a single transformation from some input
  to some output rather than as a sequence of instructions with
  intermediate state.
</p>

<p>
  John Hughes 
  <a href="http://portal.acm.org/citation.cfm?id=63411">argued</a>
  that trying to sell functional programming by saying what it couldn't do
  was not very appealing. However I believe that removing mutable
  bindings is a selling point!
</p>
<p>
  As programs grow larger,
  the interactions within them become increasingly complex and the
  temptation to use intermediate state becomes overwhelming. That
  state then becomes the conduit through which functions interact -
  some reading, some writing and some doing both. Inevitably bugs will
  surface and very often they arise because the programmer has lost
  track of where and when these updates occur.
</p>

<p>
  In functional programming, we write functions that act upon their
  inputs and return values but which don't alter any state. As a
  result, they tend to be simpler and more reusable so the programs
  that we create with them are shorter and easier to understand.
</p>

<h2>Definitions</h2>
  
<p>
A program is composed of a series of definitions. Each definition
consists of an expression bound to a symbol which yields a
value when evaluated.
</p>

<pre>
# definition of a variable
pi = 3.14159

# definition of a function
areaOfCircle = fn (r) pi * r * r end

# application of a function
areaOfCircle(10)
</pre>
  
<p>
A function is an expression and doesn't have a name. If
you need to refer to a function in your program then you bind it to a
symbol as we do above. The body of a function is also an expression
and the value of that expression is the return value of the
function. Because functions may only contain one expression and that
expression must yield a value, there's no need for a return statement
in Primer.
</p>

<p>
To see the output from a program you must
use <strong>show</strong> which is a built-in function capable of
printing any Primer expression. 
</p>

<pre>
show(areaOfCircle(5))
</pre>

<p>
In order to avoid cluttering up the text I'll omit future calls to show but you
can always add them if you want to see the result of an
evaluation. Because show is an expression and returns its argument, you
can easily output debugging information in the middle of your expressions.
</p>

<pre>
show(areaOfCircle(show(5)))
</pre>

<h2>Lists and Strings</h2>

<p>
Lists are the bread and butter data structure of functional
programming. They can be nested and in Primer are heterogeneous.
</p>

<pre>
xs1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
xs2 = [4, 5.32, pi, true, nil, areaOfCircle, areaOfCircle(5), 'a', "aaa"]
xs3 = [4, [5.32, [pi], [], true], nil, areaOfCircle, 'a', "aaa"]
</pre>

<p>
Several functions provide access to list elements.
</p>
  
<pre>
head(xs)
last(xs)
tail(xs)    # returns all but the head of the list
</pre>

<p>
You can access a list by index with the ! operator. Note that lists
are indexed from 0.
</p>

<pre>
a = 0
l = [1,2,3,4,5,6,7]
l!4
l!a
</pre>

<p>
Lists can be constructed programatically with the ++ operator.
</p>

<pre>
a ++ [a, [b, c], a] ++ 'c' ++ [4, 5, 6]
</pre>

<p>
The Primer standard library (found in base.pri) provides several
functions for working with lists such as search, sort and reverse.
</p>

<p>
Primer provides a simple character type and strings are nothing
more than lists of characters with syntactic sugar for creating them.
</p>

<pre>
# the following expression evaluates to true
"hello" == ['h', 'e', 'l', 'l', 'o']

# list processing functions and operators can be used on strings
head("hello")
"hello"!3
</pre>

<h2>Recursion</h2>

<p>
Because we can't mutate a variable, it's not possible to use iteration
in a functional programming language. Instead we use recursive
functions as in this example which counts the number of elements in a list.
</p>

<pre>
count = fn (xs)
    if xs then 1 + count(tail(xs))
    else 0
end
</pre>

<p>
As the if statement is an expression, it must return a value which
means that it must always have an else branch.
All expressions in Primer evaluate to true apart
from the explicit value nil and the empty list which both evaluate to
false. So in the above definition of count, <i>if xs then</i> means <i>if the
list represented by xs is not the empty list then</i>. Thus the function
recursively calls itself with the tail of the list, adding one to the
result until the end of the list is reached at which point the recursion
terminates and zero is returned.
</p>

<p>
An expression isn't evaluated until it's applied to arguments so a
definition can refer to a symbol which hasn't yet been defined. This
allows us to define mutually recursive functions.
</p>

<pre>
mr0 = fn (x) if x < 5 then mr1(x) else "finished!" end
mr1 = fn (x) mr0(x + 1) end
mr1(0)
</pre>

<h2>Declarative Programming</h2>

<p>
Functional programs are often said to be declarative as they describe
what a program does rather than how it does it. For example, an
imperative implementation of Quicksort tends to be defined in terms of
memory lookups, loops and shuffling data into temporary variables.
A simple functional implementation on the other hand reads more like a
statement:  <i>a sorted list is a list where the smaller
values can be found to the left of the larger values</i>.
</p>

<pre>
qsort = fn (l)
  if l then qsort(filter(lt, xs)) ++ [x] ++ qsort(filter(gte, xs))
  else []
  where x = head(l)
        xs = tail(l)
        lt = fn (a) a < x end
        gte = fn (a) a >= x end
end
</pre>

<p>
We take the head of the list as our 'pivot' value and then we
recursively sort both the values that are smaller and the values that
are larger than the pivot and concatenate the results together.
</p>

<pre>
qsort([9,3,1,7,6])                  # results in [1,3,6,7,9]
qsort("qwertyuiopasdfghjklzxcvbnm") # results in "abcdefghijklmnopqrstuvwxyz"
</pre>

<h2>Lexical Scope</h2>

<p>
Because functions may only contain one expression, programs tend to be
made up of many small functions. While this is good for modularity and
code reuse, there are times when a function is only needed in one
place. The <strong>where</strong> clause introduces local definitions.
</p>

<pre>
f = fn (x, y) a + b(y)
    where a = 125
          b = fn (n) n * a end
end
</pre>

<p>
The symbols a and b are scoped within f - they can refer to each
other, to the parameters of f and to definitions in the global scope
but they can not be accessed from outside of f.
</p>

<p>
Primer is said to be <strong>lexically scoped</strong> which means that a symbol is
bound at a given point if and only if that point is textually enclosed
by a block in which the symbol is defined, or if the symbol is
globally defined.
</p>

<p>
A binding may temporarily 'overwrite' a more global binding. This is
called <strong>shadowing</strong>.
</p>

<pre>
a = 1000

b = fn (x) x * a end

c = fn (x, y) x + a(y)
  where a = fn (x) x * 2 end
end
</pre>

<p>
Here a is defined to be the integer value 1000 at global scope. The
function b references this value. The function c however has a local
binding of a which shadows the global binding. Notice also that within
the local function a, there's a second instance of shadowing: its
parameter x shadows c's parameter x.
</p>

<p>
The basic rule is that a function will use the most local definition of a
symbol that it can find and will search outwards to successively wider scopes in
order to resolve a symbol. If no symbol is found even at the global scope then
the symbol is said to be <strong>unbound</strong> and an error is raised.
</p>

<h2>Higher Order Functions</h2>

<p>
Because functions are expressions they can be passed around
like any other value. A function which accepts another
function as an argument is called a <strong>higher order function</strong>.
</p>

<p>
Let's assume that we want to find the first number in a list which is evenly
divisible by 3.
</p>

<pre>
xs = 10..30   # the range operator creates a list of integers

findNumberDivisibleBy3 = fn (xs)
    if xs then
       if head(xs) mod 3 == 0 then head(xs)
       else findNumberDivisibleBy3(tail(xs))
    else nil
end

show(findNumberDivisibleBy3(xs))
</pre>

<p>
This works fine but is rather limited. We could parameterise the
function to search for any value of n but we can do better! Looking at
the function we can see that there are two aspects to
it: search and test. By turning search into a higher
order function we can make it more general.
</p>

<pre>
findByFun = fn (xs, f)
    if xs then
       if f(head(xs)) then head(xs)
       else findByFun(tail(xs), f)
    else nil
end

# is a number is divisible by 3
factor3 = fn (x) x mod 3 == 0 end
findByFun(xs, factor3)
</pre>

<p>
Admittedly this is more code but we can now write different test
functions to search our list.
</p>

<pre>
# is a number divisible by 3 and 5
factor3and5 = fn (x) x mod 3 == 0 and x mod 5 == 0 end
findByFun(xs, factor3and5)

# is a number odd
odd = fn (x) x mod2 != 0 end
findByFun(xs, odd)
</pre>

<p>
Not only is our search function reusable with different tests but our
tests can be reused with different search functions. For example, we
could write a search function which returns all of the values which
pass a test.
</p>

<pre>
findAllByFun = fn (f, xs)
    if xs then
       if f(head(xs)) then [head(xs)] ++ findAllByFun(f, tail(xs))
       else if tail(xs) then findAllByFun(f, tail(xs))
            else nil
    else nil
end

findAllByFun(factor3, xs)
findAllByFun(factor3and5, xs)
findAllByFun(odd, xs)
</pre>

<p>
We can even write a test function which uses our new search function.
</p>

<pre>
# is a number prime
prime = fn (p) p > 1 and length(findAllByFun(fn (n) p mod n == 0 end, 1..p)) == 2 end
</pre>

<p>
And then we can use that with either of our search functions.
</p>

<pre>
findByFun(prime, xs)
findAllByFun(prime, xs)
</pre>

<h2>Anonymous functions</h2>

<p>
We can use a function without previously assigning it to a
symbol. These so called <strong>anonymous functions</strong> are
useful when you don't want to clutter up your
program with single-use functions.
</p>

<pre>
findByFun(fn (x) x mod 2 != 0 end, xs)
</pre>

<h2>Map, reduce, filter...</h2>

<p>
Some higher order functions are so useful that they're supplied with all
functional programming languages. Map, reduce
and filter are three such examples which you'll find in the Primer
standard library.
</p>

<p>
Map applies a function to every element in a list and returns a new
list containing the transformed values.
</p>

<pre>
double = fn (x) 2 * x end
map(double, [1,2,3,4,5])      # [2,4,6,8,10]
</pre>

<p>
The implementation of map in the standard library is fairly straightforward.
</p>

<pre>
map = fn (f, xs)
    if xs then f(head(xs)) ++ map(f, tail(xs))
    else nil
end
</pre>

<p>
Reduce uses a two parameter function to combine successive list
elements as in the following example which sums the numbers in the
supplied list.
</p>

<pre>
add = fn (x, y) x + y end
reduce(add, 0, [1,2,3,4,5])   # 1+2+3+4+5=15
</pre>

<p>
This is an example of a <strong>left fold</strong> but Primer also
includes reduceRight which is an example of a <strong>right
fold</strong>. A left fold recursively combines the results of combining
all but the last element from a list with the last one. The initial
value, 0 in the example above, is combined with the first
element in the list. A right fold on the other hand recursively
combines the first element with the results of combining the rest. The
initial value is therefore combined with the last element in the list.
</p>

<p>
Again, the two implementations of reduce in the standard library
should be fairly self-explanatory.
</p>

<pre>
reduce = fn (f, init, xs)
    if xs then reduce(f, f(init, head(xs)), tail(xs))
    else init
end

reduceRight = fn (f, init, xs)
    if xs then f(head(xs), reduceRight(f, init, tail(xs)))
    else init
end
</pre>

<p>
Filter returns a new list which contains only the elements which pass
the supplied predicate function.
</p>

<pre>
filter(odd, [1,2,3,2,4,5,6])  # [1,3,5]
</pre>

<p>
The implementation of filter is a little more involved but uses only
constructs which we've already seen.
</p>

<pre>
filter = fn (f, xs)
    if xs then
       if f(head(xs)) then [head(xs)] ++ filter(f, tail(xs))
       else filter(f, tail(xs))
    else nil
end
</pre>

<p>
There are several other higher order functions supplied with Primer
such as zip, all, any, takeWhile and dropWhile. You can look at the
implementation of these by reading through the standard library code.
</p>

<h2>Closures</h2>

<p>
A closure is a first-class function which can access the variables in
its lexical environment for as long as it lives. The name comes from
the fact that the function is said to "close" over its lexical
environment, retaining it for future use. In the following example,
the return value of the makeAdder function is another function.
</p>

<pre>
makeAdder = fn (y)
    fn (a) y + a end
end
</pre>

<p>
The function returned performs a simple addition of
two variables. One of those variables is a parameter to the function
but the other is a parameter to makeAdder itself. So the returned
function is able to access a variable outside of its scope. This in
itself shouldn't be surprising as we've already seen lexical scope.
What is more interesting is that this function still works outside
the scope of makeAdder.
</p>

<p>
We can think of makeAdder as a function constructor. Here we use
it to make two new functions; one function which will add 1 to
a value and another which will add 2 to a value.
</p>

<pre>
add1 = makeAdder(1)
add2 = makeAdder(2)
</pre>

<p>
The symbols add1 and add2 now refer to functions which we can
call in exactly the same way as if we'd defined them
directly. When makeAdder returned a function, that function
captured the binding of the variable y. In the case of add1,
y was bound to 1 and in the case of add2, it was bound to 2.
</p>

<pre>
add1(2)   # 3
add2(2)   # 4
</pre>

<h2>Pattern Matching</h2>

<p>
Many functional programming languages allow you to match symbols to
data using patterns. The support for <strong>pattern matching</strong>
varies from language to language with ML derived languages and Haskell
providing many advanced features. Primer supports only <strong>list
destructuring</strong> which is a limited form of pattern
matching. Here's an example of the standard head and tail functions
written using pattern matching.
</p>

<pre>
head = fn (x:xs) x end
tail = fn (x:xs) xs end
</pre>

<p>
The single parameter to each function is broken down into two parts
representing the head of the list and the tail. Each is treated as a
symbol and is bound to the respective part of the list when the
function is applied. You can match deeper into a list.
</p>

<pre>
third = fn (x:y:z:xs) z end
</pre>

<p>
If you're only interested in part of the destructured list, you can
use a wildcard which binds against any value but doesn't create a
binding.
</p>

<pre>
head = fn (x:_) x end
tail = fn (_:xs) xs end
</pre>

<p>
Pattern matching is a useful way of reducing the amount of code you
have to write. For example, we can slightly simplify our qsort
function.
</p>

<pre>
qsort = fn (x:xs)
    if x then qsort(filter(lt, xs)) ++ [x] ++ qsort(filter(gte, xs))
    else []
    where lt = fn (a) a < x end
          gte = fn (a) a >= x end
end
</pre>

<h2>Tail Recursion</h2>

<p>
Earlier we wrote a function to count the number of elements in a list.
</p>

<pre>
count = fn (xs)
    if xs then 1 + count(tail(xs))
    else 0
end
</pre>

<p>
However, this function is not efficient and will crash on a
sufficiently long list! In most programming languages, every time a
function is called, information is pushed onto the stack which contains
the details of the function including its parameters and where it
should return its value to. The stack is usually of a fixed size
meaning that unbounded recursion can lead to a <strong>stack overflow</strong>.
</p>

<p>
Most functional programming languages require that their runtimes
eliminate some of the recursive 
calls in a users program. Typically this can only be done if the
recursive call is the last thing that the function does. In practice,
<strong>tail calls</strong> are common so this <strong>tail call
optimisation</strong> is beneficial. However, not all functions are
naturally tail recursive and our count function is one which needs to
be adjusted to take advantage of the optimisation.
</p>

<p>
The problem with count is that the last thing it does is to call the
addition operator. We can rewrite count to use an
<strong>accumulator function</strong>.
</p>

<pre>
count = fn (xs) counter(0, xs)
 where counter = fn (a, xs)
           if xs then counter(a+1, rest(xs))
           else a
end
</pre>

<p>
Accumulators are a common technique used to make this type of summing
function tail recursive by moving the summing operation away from the
tail call.
</p>

<h2>Problem: Mars Rovers</h2>

<p>
The following is a slightly modified version of a problem which
<a href="http://www.thoughtworks.com/">ThoughtWorks</a>
give to interview candidates.
</p>

<div class="quote">
<p>
A robotic rover is to be landed by NASA on a rectangular plateau of
Mars. The rover must navigate the plateau using a set of commands sent
from Earth. The plateau is divided into a grid to simplify navigation.
<p>

<p>
A rover's position is represented by a combination of an x and y
co-ordinate and a letter representing one of the four cardinal compass
points. An example position on the grid might be [0,0,N] which means
the rover is in the bottom left corner and facing North. Assume that
the square directly North from (x, y) is (x, y+1).
<p>

<p>
The input to the rover is via two functions:
<br/><br/>
1. position(x, y, h) deploys the rover to an initial grid location [x,y,h].
<br/><br/>
2. move(s) accepts a command string of the form "L1R2". L spins the
rover 90 degrees left, R spins the rover 90 degrees right and a number
moves the rover by the appropriate number of grid points in the
direction it's currently facing. The command string can be of any
reasonable length.
</p>

<p>
Test your program by starting in an initial position [10,10,N] and
then issuing the command "R1R3L2L1". The output from the program should
be the final grid location and heading of the rover.
</p>
</div>

<p>
I encourage you to write your own solution but here's my attempt.
</p>

<pre>
W = 0 S = 1 E = 2 N = 3
dirs = ['W', 'S', 'E', 'N']

position = fn (x, y, h) [x, y, h] end
print = fn (x:y:h:_) show([x, y, dirs!(h)]) end

move = fn (r, s)
    reduce(transform, r, s)
    where transform = fn (x:y:h:_, c)
              if c == 'L' then [x, y, (h + 1) mod 4]
              else if c == 'R' then [x, y, rotr(h) - 1]
              else translate(x, y, h, c - '0')
          end
          rotr = fn (h) if h == 0 then 4 else h end
          translate = fn (x, y, h, c)
              if even(h) then [x + ((h - 1) * c), y, h]
              else [x, y + ((h - 2) * c), h]
          end
end

print(move(position(10, 10, N), "R1R3L2L1"))
</pre>

<h2>Where next?</h2>

<p>
You've now learnt the foundations of functional programming and are
ready to move on to something more powerful. There are many options to
choose from including <a href="http://haskell.org/">Haskell</a>,
<a href="http://clojure.org/">Clojure</a>,
<a href="http://msdn.microsoft.com/en-gb/fsharp/default.aspx">F#</a>
and <a href="http://caml.inria.fr/">OCaml</a>. I urge you
to look at each of them!
</p>

<p>
Whichever language you choose I hope Primer has proved to
be a useful introduction to functional programming and I'd like to
hear your comments and suggestions for improvements.
</p>

<h2>Thanks...</h2>

<p>
I'm extremely grateful to Michael Ben-Yosef for his
invaluable input into the design of both the language and the
tutorial. His ability to debug Primer code without a working copy of the
interpreter is quite extraordinary!
</p>

<hr/>
&copy; 2010 <a href="mailto:philip.armitage@gmail.com">Phil Armitage</a>
</div>
</body>
</html>
