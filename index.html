<html>
<head>
<title>Primer</title>
<style>
	body {
		font-family: sans-serif;
		line-height: 140%;
		width: 800px;
		margin: 30px 0px 20px 30px;
		padding: 10px;
	}
	pre {
		font-family: monospace;
		font-size: 14px;
		background: #f1f1f1;
		border-left: 2px solid black;
		margin-right: 10px;
		margin-left: 13px;
		padding: 3px 0 3px 12px;
	}
	a {
		text-decoration: none;
		color: blue;
	}
	a:hover {
		background: blue;
		color: white;
	}
	h2 {
		margin-top: 30px;
	}
</style>
</head>
<body>
<h1>Primer</h1>
<p>
	Primer is a simple, dynamically typed, interpreted programming language
	and comes with a small standard library. Please note that as it's my
	hobby project, Primer is just for fun and not intended as a replacement
	for your favourite programming language!
</p>
<p>
	If you have any comments or questions, please
	<a href="mailto:philip.armitage@gmail.com">email</a> me.
</p>

<h2>Download and install</h2>
<p>
	An alpha version will be released shortly for Linux, Mac and Windows.
	The source code will be available under the MIT license.	
</p>
<p>
	Unpack the tarball and ensure that the Primer binary is somewhere on
	your PATH. Create the environment variable PRIMER_LIBRARY_PATH and set
	it to the path where stdlib.pri will live on your system. To test that
	everything's working, enter the following code into a text file and save
	it as hello.pri.
</p>
<pre>
show("Hello, world!")
</pre>
<p>
	At the shell enter:
</p>
<pre>
$ primer hello.pri
</pre>
<p>
	If you receive the error message "Unable to find standard library..."
	then you may need to restart your shell for the change to take effect.
</p>

<h2>Definitions</h2>
<p>
	Definitions, created with the <strong>def</strong> keyword, intern a new
	symbol which can be bound to a value, an expression or a function
	definition. Values can be integers, floating point numbers, booleans,
	characters or strings as well as the value <strong>nil</strong> which
	represents nothing.
</p>
<pre>
def i = 10
def f = 3.14
def b = true
def c = 'z'
def s = "Hello, world!"
</pre>
<p>
	You can also create multiple definitions at a time.
</p>
<pre>
def foo = 12, bar = true, baz = 1.112
</pre>
<p>
	A binding can be reassigned using <strong>set</strong> and because
	Primer is dynamically typed, the type need not be the same.
</p>
<pre>
def x = 12
set x = true
</pre>
<p>
	A number of functions are provided by the standard library for
	determining the type of a variable. The <strong>type</strong> function
	returns an integer code while the named type predicate functions return
	a boolean value indicating if the supplied object is of that type.
</p>
<pre>
type(i)
integer(i)
float(f)
bool(b)
char(c)
function(square)
</pre>
<p>
	Functions are introduced with the <strong>fn</strong> keyword. They are
	first class objects so can be bound to a symbol, passed to another
	function or stored in a list. Functions can be nested to an arbitrary
	depth and are lexically scoped. They return the value of the last
	executed expression and can be called recursively. The following example
	shows a higher order function being passed both a named and an anonymous
	function.
</p>
<pre>
def square = fn(x)
    x * x
end

def addfuns = fn(f1, f2, x)
    f1(x) + f2(x)
end

addfuns(square, fn (x) x + x end, 5)
</pre>

<h2>Statements</h2>
<p>
	Primer provides a few built in statements. Both <strong>if</strong>
	statements and <strong>while</strong> loops work with boolean predicates
	or integer expressions. The if statement can have an optional
	<strong>else</strong> clause and can be nested to any depth.
</p>
<pre>
while (b == true)
    if (x > 3000)
        set x = x - 10
    else
        set b = false
    end
end
</pre>
<p>
	The <strong>iter</strong> statement loops over the elements of a list.
	Note that if the list is modified in the loop body, the effect will not
	be visible until the loop has terminated.
</p>
<pre>
iter (e : [1,2,3])
    show(e)
end
</pre>
<p>
	The <strong>let</strong> block creates a new lexical environment,
	bringing bindings into scope for the duration of its body.
</p>
<pre>
let (w = [1,2,3])
    show(w)
    let (w = nil, x = 12, y = 4, z = true)
        show([x + y] ++ [z, w])
    end
    show(w)
end
</pre>
<p>
	Functions, if, let, for and while all introduce their own lexical
	environments and because Primer is lexically scoped, bindings can be
	shadowed.
</p>

<h2>Lists</h2>
<p>
	Lists are heterogeneous and can be nested to an arbitrary depth.
	They can be concatenated with the <strong>++</strong> operator. List
	equality is tested element-wise and nested lists are tested recursively.
	The empty list is equal to nil.
</p>
<pre>
def simple = [1,2,3]
def nested = [1,2,[12,15,16,[44],67],3,3,4,2]
def mixed = [1, true, 11128.775, square, 'Y', nil, "foo"]
def new = simple ++ nested ++ mixed ++ [x, y]
</pre>
<p>
	An atomic item can be prepended to a list with the <strong>cons</strong>
	special form.
</p>
<pre>
def extended = cons(0, [1,2,3])
</pre>
<p>
	A number of special forms and standard library functions provide ways of
	accessing list elements and testing the properties of lists.
</p>
<pre>
head([1,2,3])
tail([1,2,3])
last([1,2,3])
nth([1,2,3], 0)
length([1,2,[3,4,5,6,7],6])
empty([])
</pre>
<p>
	String are just lists of characters with additional syntactic sugar
	which means that many list operations can be used with them.
</p>
<pre>
def name = "John " ++ "Smith"
show(reverse(name))
set name = sort(name)
</pre>

<h2>Operators</h2>
<p>
	The standard mathematical operators have precedence as in C.
</p>
<pre>
12 + 3 * 2 / 5 % 2
</pre>
<p>
	The standard logical operators are also available (not all are shown).
</p>
<pre>
a == 15 && c != 12 || a <= 6
</pre>
<p>
	The range operator creates a list of integers between lower and upper
	bounds (inclusive).
</p>
<pre>
50..300
</pre>

<h2>Standard Library</h2>
<p>
	The standard library, found in stdlib.pri, is a small collection of
	functions that are automatically loaded by the interpreter before it
	evaluates your program. All of these functions are written in Primer
	itself so you are free to change the implementation of them as you see
	fit (for example, some are written in a deliberately functional style to
	keep them short and elegant but could be rewritten imperatively to
	improve efficiency).
</p>
<p>
	Note that a small number of functions are actually special forms: cons,
	head, tail, type and show.
</p>
<p>
	As Primer makes heavy use of lists, many of the standard library
	functions relate to manipulating them. The following describes some of
	the most interesting functions but other facilities include searching,
	sorting and summing.
</p>
<p>
	The <strong>map</strong> function transforms the values of a
	list by applying a function to each member in turn and returning a new
	list containing the results. The supplied function should take one
	argument and return one value.
</p>
<pre>
def square = fn (x)
    x * x
end

map(square, [1,2,3])
</pre>
<p>
	The <strong>filter</strong> function applies a predicate to each member
	of a list, returning a new list consisting of those elements for
	which the predicate returns true. The predicate should be a function
	taking one argument and returning a boolean.
</p>
<pre>
filter(even, [1,2,3,4,5])
</pre>
<p>
	Fold, sometimes known as 'reduce', is implemented as two higher order
	functions, <strong>foldl</strong> and <strong>foldr</strong>. It
	processes a list by combining elements using a binary
	function and returns a result. The foldl function (left fold)
	recursively combines the results of combining all but the last element
	of the list with the last one. The foldr function (right fold)
	recursively combines the first element of the list with the results of
	combining the tail of the list. An initial value is used for combining
	the elements at the end of the list.
</p>
<pre>
foldl(fn (x, y) x + y end, 0, [1,2,3,4,5])
foldr(fn (x, y) x + y end, 0, [1,2,3,4,5])
</pre>
<p>
	The <strong>zip</strong> function combines elements from two lists,
	pairwise, into a new list. If the lists are of unequal length, the
	resultant list will contain as many elements as the shortest list.
</p>
<pre>
zip([1,2,3], [4,5,6])
</pre>
</body>
</html>