<html>
<head>
<title>Primer</title>
<style>
	body {
		font-family: sans-serif;
		line-height: 140%;
		width: 800px;
		margin: 30px 0px 20px 30px;
		padding: 10px;
	}
	pre {
		font-family: monospace;
		font-size: 14px;
		background: #f1f1f1;
		border-left: 2px solid black;
		margin-right: 10px;
		margin-left: 13px;
		padding: 3px 0 3px 12px;
	}
	a {
		text-decoration: none;
		color: blue;
	}
	a:hover {
		background: blue;
		color: white;
	}
	h2 {
		margin-top: 30px;
	}
</style>
</head>
<body>
<h1>Primer</h1>
<p>
	Primer is a dynamically typed programming language with a mixture of
	imperative and functional facilities. If you have any
	comments or questions, please feel free to
	<a href="mailto:philip.armitage@gmail.com">email</a> me.
</p>

<h2>Download and install</h2>
<p>
	An alpha version will be released shortly for Linux, Mac and Windows.
	The source code will be available under the MIT license.	
</p>
<p>
	Unpack the tarball and ensure that the Primer binary is somewhere on
	your PATH. Create the environment variable PRIMER_LIBRARY_PATH and set
	it to the path where stdlib.pri will live on your system. To test that
	everything's working, enter the following code into a text file and save
	it as hello.pri.
</p>
<pre>
show("Hello, world!")
</pre>
<p>
	At the shell enter:
</p>
<pre>
$ primer hello.pri
</pre>
<p>
	If you receive the error message "Unable to find standard library..."
	then you may need to restart your shell for the environment variable to
	be exported correctly.
</p>

<h2>Definitions</h2>
<p>
	Definitions, created with the <strong>def</strong> keyword, intern a new
	symbol which can be bound to a value, an expression or a function
	definition. Values can be integers, floating point numbers, booleans,
	characters or strings as well as the value <strong>nil</strong> which
	represents nothing.
</p>
<pre>
def i = 10
def f = 3.14
def b = true
def c = 'z'
def s = "Hello, world!"
</pre>
<p>
	You can create multiple definitions at a time.
</p>
<pre>
def foo = 12, bar = true, baz = 1.112
</pre>
<p>
	A binding can be reassigned using <strong>set</strong>.
</p>
<pre>
def x = 12
set x = true
</pre>
<p>
	A number of functions are provided by the standard library for
	determining the type of a variable. The <strong>type</strong> function
	returns an integer code while the type predicate functions return
	a boolean value indicating if the supplied object is of that type.
</p>
<pre>
type(i)
isint(i)
isfloat(f)
isbool(b)
ischar(c)
isfn(square)
</pre>
<p>
	Functions are introduced with the <strong>fn</strong> keyword. They are
	first class objects so can be bound to a symbol, passed to another
	function or stored in a list. Functions can be nested to an arbitrary
	depth and are lexically scoped. They return the value of their last
	executed expression and can be called recursively. The following example
	shows a higher order function being passed both a named and an anonymous
	function.
</p>
<pre>
def square = fn(x)
    x * x
end

def addfuns = fn(f1, f2, x)
    f1(x) + f2(x)
end

addfuns(square, fn (x) x + x end, 5)
</pre>

<h2>Statements</h2>
<p>
	Primer provides a few built in statements. Both <strong>if</strong>
	statements and <strong>while</strong> loops work with boolean predicates
	or integer expressions. The if statement can have an optional
	<strong>else</strong> clause and can be nested to any depth.
</p>
<pre>
while (b == true)
    if (x > 3000)
        set x = x - 10
    else
        set b = false
    end
end
</pre>
<p>
	The <strong>iter</strong> statement loops over the elements of a list.
	Note that if the list is modified in the loop body, the effect will not
	be visible until the loop has terminated.
</p>
<pre>
iter (e : [1,2,3])
    show(e)
end
</pre>
<p>
	The <strong>let</strong> block creates a new lexical environment,
	bringing bindings into scope for the extent of its body.
</p>
<pre>
let (w = [1,2,3])
    show(w)
    let (w = nil, x = 12, y = 4, z = true)
        show([x + y] ++ [z, w])
    end
    show(w)
end
</pre>
<p>
	Note that fn, if, for and while also introduce their own lexical
	environments. Because Primer is lexically scoped, bindings can be
	shadowed.
</p>

<h2>Lists</h2>
<p>
	Lists are heterogeneous and can be nested to an arbitrary depth.
	They can be concatenated with the <strong>++</strong> operator. List
	equality is tested element-wise and nested lists are tested recursively.
	The empty list is equal to nil.
</p>
<pre>
def simple = [1,2,3]
def nested = [1,2,[12,15,16,[44],67],3,3,4,2]
def mixed = [1, true, 11128.775, square, 'Y', nil, "foo"]
def new = simple ++ nested ++ mixed ++ [x, y]
</pre>
<p>
	An atomic item can be prepended to a list with <strong>cons</strong>.
</p>
<pre>
def extended = cons(0, [1,2,3])
</pre>
<p>
	A number of functions provide access to list elements such as
	<strong>head</strong>, <strong>tail</strong>, <strong>last</strong>
	and <strong>nth</strong>.
</p>
<pre>
head([1,2,3])
tail([1,2,3])
last([1,2,3])
nth([1,2,3], 0)
</pre>
<p>
	String are lists of characters with additional syntactic sugar meaning
	that many list operations such as ++, <strong>length</strong>,
	<strong>reverse</strong> and <strong>sort</strong> can be used with
	them.
</p>
<pre>
def name = "John " ++ "Smith"
show(length(name))
set name = reverse(sort(name))
</pre>

<h2>Operators</h2>
<p>
	The standard mathematical operators have precedence as in C.
</p>
<pre>
12 + 3 * 2 / 5 % 2
</pre>
<p>
	The standard logical operators are also available (not all are shown).
</p>
<pre>
a == 15 && c != 12 || a <= 6
</pre>
<p>
	The range operator creates a list of integers between lower and upper
	bounds (inclusive).
</p>
<pre>
50..300
</pre>

<h2>Standard Library</h2>
<p>
	The standard library, found in stdlib.pri, is a small collection of
	functions that are automatically loaded by the interpreter before it
	evaluates your program. All of these functions are written in Primer
	itself so you are free to change the implementation of them as you see
	fit (for example, some are written in a deliberately functional style to
	keep them short and elegant but could be rewritten imperatively to
	improve efficiency).
</p>
<p>
	Note that a small number of functions are actually special forms: cons,
	head, tail, type and show.
</p>
<p>
	As Primer makes heavy use of lists, many of the standard library
	functions relate to manipulating them. The following describes some of
	the most interesting functions but other facilities include searching,
	sorting and summing.
</p>
<p>
	The <strong>map</strong> function transforms the values of a
	list by applying a function to each member in turn and returning a new
	list containing the results. The supplied function should take one
	argument and return one value.
</p>
<pre>
def square = fn (x)
    x * x
end

map(square, [1,2,3])
</pre>
<p>
	The <strong>filter</strong> function applies a predicate to each member
	of a list, returning a new list consisting of those elements for
	which the predicate returns true. The predicate should be a function
	taking one argument and returning a boolean.
</p>
<pre>
filter(even, [1,2,3,4,5])
</pre>
<p>
	Fold, sometimes known as 'reduce', is implemented as two higher order
	functions, <strong>foldl</strong> and <strong>foldr</strong>. It
	processes a list by combining elements using a binary
	function and returns a result. The foldl function (left fold)
	recursively combines the results of combining all but the last element
	of the list with the last one. The foldr function (right fold)
	recursively combines the first element of the list with the results of
	combining the tail of the list. An initial value is used for combining
	the elements at the end of the list.
</p>
<pre>
foldl(fn (x, y) x + y end, 0, [1,2,3,4,5])
foldr(fn (x, y) x + y end, 0, [1,2,3,4,5])
</pre>
<p>
	The <strong>zip</strong> function combines elements from two lists,
	pairwise, into a new list. If the lists are of unequal length, the
	resultant list will contain as many elements as the shortest list.
</p>
<pre>
zip([1,2,3], [4,5,6])
</pre>
</body>
</html>