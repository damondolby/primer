<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html> 
<head> 

<title>Primer</title>
<meta name="google-site-verification" content="vgeoiUGsO_K7Rc1xaw97CHqm_qZ8WtGiPZbN7ZkroEY" />
<style>
html {
background: #c1c1c1;
color: #222;
}

div#content {
background: white;
font-family: verdana, "trebuchet ms", "Helvetica Neue", Helvetica, Arial, sans-serif;
-moz-border-radius: 1.5em;
-webkit-border-radius: 1.5em;
border-radius: 1.5em;
line-height: 140%;
width: 900px;
margin: 20px auto;
padding: 30px;
}

pre {
font-family: monospace;
background: #f1f1f1;
border-left: 2px solid black;
margin-right: 10px;
margin-left: 13px;
padding: 3px 0 3px 12px;
}

h1 {
font-size: 18pt;
}

h2 {
font-size: 14pt;
margin-top: 40px;
}

strong {
color: #f14141;
font-weight: normal;
}

div.quote {
padding: 5px 20px 5px 20px;
border: 1px dashed black;
font-style: italic;
text-align: justify;
}
</style> 
</head> 
<body>
<div id="content">

<h1>An introduction to Functional Programming with Primer</h1>
<hr/>

<p>
  Primer is a simple language designed to introduce the basics of
  functional programming in an afternoon. The knowledge you'll gain is
  transferable to other functional languages.
</p>

<h2>Download</h2>
  
  <p>
  Primer is under active development and until the GC is written, is only
  available on <a href="http://github.com/parmitage/primer">github</a>:
  </p>

  <pre>git clone http://github.com/parmitage/primer.git</pre>

  <p>
  Primer has been tested on Linux, MacOS X and Windows. You need to
  have GNU make, gcc, flex and bison installed. Primer relies upon the
  environment variable PRIMER_LIBRARY_PATH being set on your
  system. This should point to the path containing the file
  Library.pri and should be terminated with a '/' e.g. with bash
  </p>
  
  <pre>export PRIMER_LIBRARY_PATH=/Users/phil/Primer/</pre>

  <p>
  If you have any comments or questions in the meantime then please feel
  free to <a href="mailto:philip.armitage@gmail.com">email me</a>.
  </p>

<h2>What is functional programming?</h2>

<p>
  Functional programming is a way of writing programs without relying
  on the mutation of state. The result is that a functional
  program can be thought of as a single transformation from some input
  to some output rather than as a sequence of instructions with
  intermediate state.
</p>

<p>
  John Hughes 
  <a href="http://portal.acm.org/citation.cfm?id=63411">argued</a>
  that trying to sell functional programming by saying what it couldn't do
  was not very appealing. However I believe that removing mutable
  bindings is a selling point!
</p>
<p>
  As programs grow larger,
  the interactions within them become increasingly complex and the
  temptation to use intermediate state becomes overwhelming. That
  state then becomes the conduit through which functions interact -
  some reading, some writing and some doing both. Inevitably bugs will
  surface and very often they arise because the programmer has lost
  track of where and when these updates occur.
</p>

<p>
  In functional programming, we write functions that act upon their
  inputs and return values but which don't alter any state. As a
  result, they tend to be simpler and more reusable so the programs
  that we create with them are shorter and easier to understand.
</p>

<h2>Conventions used in this tutorial</h2>

<p>
Code can be taken from this tutorial and pasted into a text file
without modification. Some expressions may depend upon
definitions which were previously introduced but for brevity I won't
repeat them. Note that Primer allows definitions to be redefined in the order
that they appear in the source code.
</p>

<p>
Comments are introduced with the # character and extend to the end of
the line. I will sometimes place comments above or to the side of an
expression with ==> to signify the output of the expression but this
has no special meaning in Primer.
</p>

<pre>
2 + 3    # ==> 5
</pre>
  
<h2>Definitions</h2>
  
<p>
A program is composed of a series of definitions. Each definition
consists of an expression bound to a symbol which yields a
value when evaluated.
</p>

<pre>
# definition of a variable
pi = 3.14159

# definition of a function
areaOfCircle = fn (r) pi * r * r end

# application of a function
areaOfCircle(10)
</pre>
  
<p>
A function is an expression and doesn't have a name. If
you need to refer to a function in your program then you bind it to a
symbol as we do above. The body of a function is also an expression
and the value of that expression is the return value of the
function. Because functions may only contain one expression and that
expression must yield a value, there's no need for a return statement
in Primer.
</p>

<p>
To see the output from a program you must
use <strong>show</strong> which is a built-in function capable of
printing any Primer expression. 
</p>

<pre>
show(areaOfCircle(5))
</pre>

<p>
In order to avoid cluttering up the text I'll omit future calls to show but you
can always add them if you want to see the result of an
evaluation. Because show is an expression and returns its argument, you
can easily output debugging information in the middle of your expressions.
</p>

<pre>
show(areaOfCircle(show(x)))
</pre>

<p>
Parameters are evaluated from right to left.
</p>

<h2>Lists and Strings</h2>

<p>
Lists are the bread and butter data structure of functional
programming. They can be nested and in Primer are heterogeneous.
</p>

<pre>
xs1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
xs2 = [4, 5.32, pi, true, areaOfCircle, areaOfCircle(5), 'a', "aaa"]
xs3 = [4, [5.32, [pi], [], true], areaOfCircle, 'a', "aaa"]
</pre>

<p>
Several functions provide access to list elements.
</p>
  
<pre>
head(xs1)    # ==> 0
last(xs1)    # ==> 9
tail(xs1)    # ==> [1, 2, 3, 4, 5, 6, 7, 8, 9]
length(xs1)  # ==> 10
</pre>

<p>
You can access a list by index with the ! operator. Note that lists
are indexed from 0.
</p>

<pre>
a = 0
xs1!4        # ==> 4
xs1!a        # ==> 0
</pre>

<p>
Lists can be constructed programatically with the ++ operator.
</p>

<pre>
a ++ [a, [b, c], a] ++ 'c' ++ [4, 5, 6]
</pre>

<p>
The Primer standard library (found in base.pri) provides several
functions for working with lists such as search, sort and reverse.
</p>

<p>
Primer provides a simple character type and strings are nothing
more than lists of characters with syntactic sugar for creating
them. This means that operators designed for use with lists can often
be used with strings.
</p>

<pre>
"hello" == ['h', 'e', 'l', 'l', 'o']    # ==> true
head("hello")
"hello"!3
</pre>

<h2>Recursion</h2>

<p>
Because we can't mutate a variable, it's not possible to use iteration
in a functional programming language. Instead we use recursive
functions as in this example which counts the number of elements in a list.
</p>

<pre>
count = fn (xs)
    if xs != [] then 1 + count(tail(xs))
    else 0
end
</pre>

<p>
As the if statement is an expression, it must return a value which
means that it must always have an else branch. Count recursively calls
itself with the tail of the list, adding one to the result until the
end of the list is reached at which point the recursion terminates and
zero is returned.
</p>

<p>
The expression inside a function isn't evaluated until the function
is applied, so a definition can refer to a symbol which hasn't yet
been defined. This allows us to define mutually recursive functions.
</p>

<pre>
mr0 = fn (x) if x < 5 then mr1(x) else "finished!" end
mr1 = fn (x) mr0(x + 1) end
mr1(0)
</pre>

<h2>Lexical Scope</h2>

<p>
Because functions may only contain one expression, programs tend to be
made up of many small functions. While this is good for modularity and
code reuse, there are times when a function is only needed in one
place. The <strong>where</strong> clause introduces local definitions.
</p>

<pre>
f = fn (x, y) a + b(y)
    where a = 125
          b = fn (n) n * a end
end
</pre>

<p>
The symbols a and b are scoped within f - they can refer to each
other, to the parameters of f and to definitions in the global scope
but they can not be accessed from outside of f.
</p>

<p>
Primer is said to be <strong>lexically scoped</strong> which means that a symbol is
bound at a given point if and only if that point is textually enclosed
by a block in which the symbol is defined, or if the symbol is
globally defined.
</p>

<p>
A binding may temporarily 'overwrite' a more global binding. This is
called <strong>shadowing</strong>.
</p>

<pre>
a = 1000

b = fn (x) x * a end

c = fn (x, y) x + a(y)
  where a = fn (x) x * 2 end
end
</pre>

<p>
Here a is defined to be the integer value 1000 at global scope. The
function b references this value. The function c however has a local
binding of a which shadows the global binding. Notice also that within
the local function a, there's a second instance of shadowing: its
parameter x shadows c's parameter x.
</p>

<p>
The basic rule is that a function will use the most local definition of a
symbol that it can find and will search outwards to successively wider scopes in
order to resolve a symbol. If no symbol is found even at the global scope then
the symbol is said to be <strong>unbound</strong> and an error is raised.
</p>

<h2>Higher Order Functions</h2>

<p>
Because functions are values they can be passed around like any other
value. More precisely, an expression of the form
</p>

<pre>
fn (...) ... end
</pre>

<p>
is referred to as a <strong>function expression</strong> (or sometimes
a <strong>lambda expression</strong>).
</p>

<p>A function which accepts another function as an argument is called
a <strong>higher order function</strong>. Let's assume that we want to
find the first number in a list which is evenly divisible by 3.
</p>

<pre>
xs = 10..30   # the range operator creates a list of integers

findNumberDivisibleBy3 = fn (xs)
    if xs != [] then
       if head(xs) mod 3 == 0 then head(xs)
       else findNumberDivisibleBy3(tail(xs))
    else []
end

show(findNumberDivisibleBy3(xs))
</pre>

<p>
This works but is rather limited. We could parameterise the
function to search for any value of n but we can do better! Looking at
the function we can see that there are two aspects to
it: search and test. By turning search into a higher
order function we can make it more general.
</p>

<pre>
findByFun = fn (xs, f)
    if xs != [] then
       if f(head(xs)) then head(xs)
       else findByFun(tail(xs), f)
    else false
end

# is a number divisible by 3
factor3 = fn (x) x mod 3 == 0 end
findByFun(xs, factor3)
</pre>

<p>
Admittedly this is more code but we can now write different test
functions to search our list.
</p>

<pre>
# is a number divisible by 3 and 5
factor3and5 = fn (x) x mod 3 == 0 and x mod 5 == 0 end
findByFun(xs, factor3and5)

# is a number odd
odd = fn (x) x mod 2 != 0 end
findByFun(xs, odd)
</pre>

<p>
Not only is our search function reusable with different tests but our
tests can be reused with different search functions. For example,
rather than just finding the first value in a list which passes a
test, we can write a search function which returns all of the values
which pass.
</p>

<pre>
findAllByFun = fn (f, xs)
    if xs != [] then
       if f(head(xs)) then [head(xs)] ++ findAllByFun(f, tail(xs))
       else findAllByFun(f, tail(xs))
    else []
end

findAllByFun(factor3, xs)
findAllByFun(factor3and5, xs)
findAllByFun(odd, xs)
</pre>

<p>
We can even write a test function which uses our new search function.
</p>

<pre>
# is a number prime
prime = fn (p) p > 1 and length(findAllByFun(fn (n) p mod n == 0 end, 1..p)) == 2 end
</pre>

<p>
And then we can use that with either of our search functions.
</p>

<pre>
findByFun(prime, xs)
findAllByFun(prime, xs)
</pre>

<h2>Anonymous functions</h2>

<p>
We can use a function without previously assigning it to a
symbol. These <strong>anonymous functions</strong> are
useful when you don't want to clutter up your
program with single-use functions.
</p>

<pre>
findByFun(fn (x) x mod 2 != 0 end, xs)
</pre>

<h2>Pattern Matching</h2>

<p>
Many functional programming languages allow you to bind symbols to
data using patterns. The support for <strong>pattern matching</strong>
varies greatly from language to language and Primer supports only
<strong>list de-structuring</strong>. Here's an example of the
standard head and tail functions which use pattern matching.
</p>

<pre>
head = fn (x:xs) x end
tail = fn (x:xs) xs end
</pre>

<p>
Both functions take only a single parameter, which must be a list. The
list is automatically de-structured into the head, which is bound to
x, and the tail, which is bound to xs, when the function is applied.
</p>

<p>
You can match as far into a list as you need. Each part of the
pattern matches one element in the list except for the last which
matches the rest.
</p>

<pre>
third = fn (x:y:z:xs) z end
</pre>

<p>
If you're only interested in part of the de-structured list, you can
use a wildcard which binds against any value but doesn't create a
binding.
</p>

<pre>
head = fn (x:_) x end
tail = fn (_:xs) xs end
</pre>

<p>
De-structuring is a useful way of simplifying your function definitions.
</p>

<h2>Mapping, folding and filtering</h2>

<p>
These three operations are so fundamental that all functional
languages provide an implementation of them. Map applies a function to
every element in a list and returns a new list containing the
transformed values.
</p>

<pre>
double = fn (x) 2 * x end
map(double, [1,2,3,4,5])      # [2,4,6,8,10]
</pre>

<p>
The implementation of map in the standard library is quite straightforward.
</p>

<pre>
map = fn (f, x:xs)
   if x != [] then f(x) ++ map(f, xs)
   else []
end
</pre>

<p>
Fold, sometimes known as <strong>reduce</strong>, uses a two parameter
function to combine successive list elements. In the following
example, we sum the elements of the list.
</p>

<pre>
add = fn (x, y) x + y end
foldl(add, 0, [1,2,3,4,5])   # ==> ((((0+1)+2)+3)+4)+5 = 15
foldr(add, 0, [1,2,3,4,5])   # ==> 1+(2+(3+(4+(5+0)))) = 15
</pre>

<p>
Note that there are actually two fold functions.
A <strong>left fold</strong> (foldl) recursively combines the results of
combining all but the last element from a list with the last one. The
initial value, 0 in the example above, is combined with the first
element in the list. A <strong>right fold</strong> (foldr) on the other hand
recursively combines the first element with the results of combining
the rest. The initial value is therefore combined with the last
element in the list.
</p>

<p>
Again, the implementations of these two functions should be fairly
self-explanatory.
</p>

<pre>
foldl = fn (f, init, x:xs)
   if x != [] then foldl(f, f(init, x), xs)
   else init
end

foldr = fn (f, init, x:xs)
   if x != [] then f(x, foldr(f, init, xs))
   else init
end
</pre>

<p>
Filter returns a new list which contains only the elements which pass
a predicate function.
</p>

<pre>
filter(odd, [1,2,3,2,4,5,6])  # [1,3,5]
</pre>

<p>
The implementation of filter should look familiar to you from earlier!
</p>

<pre>
filter = fn (f, y:ys)
   if y != [] then
      if f(y) then [y] ++ filter(f, ys)
      else filter(f, ys)
   else []
end
</pre>

<p>
There are several other higher order functions supplied with Primer
such as zip, all, any, takeWhile and dropWhile. You can look at the
implementation of these by reading through the standard library code.
</p>

<h2>Closures</h2>

<p>
A closure is a first-class function which can access the variables in
its lexical environment for as long as it lives. The function is said
to "close" over its lexical environment, retaining it for future
use. In the following example, the return value of the makeAdder
function is another function.
</p>

<pre>
makeAdder = fn (y)
    fn (a) y + a end
end
</pre>

<p>
The function returned performs a simple addition of
two variables. One of those variables is a parameter to the function
but the other is a parameter to makeAdder itself. So the returned
function is able to access a variable outside of its scope. This in
itself shouldn't be surprising as we've already seen lexical scope.
What is more interesting is that this function still works outside
the scope of makeAdder.
</p>

<p>
We can think of makeAdder as a function constructor. Here we use
it to make two new functions; one function which will add 1 to
a value and another which will add 2 to a value.
</p>

<pre>
add1 = makeAdder(1)
add2 = makeAdder(2)
</pre>

<p>
The symbols add1 and add2 now refer to functions which we can
call in exactly the same way as if we'd defined them
directly. When makeAdder returned a function, that function
captured the binding of the variable y. In the case of add1,
y was bound to 1 and in the case of add2, it was bound to 2.
</p>

<pre>
add1(2)   # 3
add2(2)   # 4
</pre>

<h2>Tail Recursion</h2>

<p>
Earlier we wrote a function to count the number of elements in a list.
</p>

<pre>
count = fn (xs)
    if xs then 1 + count(tail(xs))
    else 0
end
</pre>

<p>
However, this function is not efficient and will crash on a
sufficiently long list. In most programming languages, every time a
function is called, information is pushed onto the stack including
parameter information and where it should return its value to. The
stack is usually of a fixed size meaning that unbounded recursion can
lead to a <strong>stack overflow</strong>.
</p>

<p>
Most functional programming languages require that their runtimes
eliminate some of the recursive calls in a users program, turning them
into jumps that do not consume stack space. Typically this can only be done if the
recursive call is the last thing that the function does. In practice,
<strong>tail calls</strong> are common so this <strong>tail call
optimisation</strong> is beneficial. However, not all functions are
naturally tail recursive and our count function is one which needs to
be adjusted to take advantage of the optimisation.
</p>

<p>
The problem with count is that the last thing it does is not the
recursive call but rather a call to the addition operator. We can
rewrite count to use an <strong>accumulator function</strong>.
</p>

<pre>
count = fn (xs) counter(0, xs)
    where counter = fn (a, xs)
              if xs then counter(a + 1, rest(xs))
              else a
          end
end
</pre>

<p>
Accumulators are a common technique used to make this type of summing
function tail recursive by moving the summing operation away from the
tail call.
</p>

<h2>Problem: Mars Rovers</h2>

<p>
The following is a slightly modified version of a problem which
<a href="http://www.thoughtworks.com/">ThoughtWorks</a>
give to interview candidates.
</p>

<div class="quote">
<p>
A robotic rover is to be landed by NASA on a rectangular plateau of
Mars. The rover must navigate the plateau using a set of commands sent
from Earth. The plateau is divided into a grid to simplify navigation.
<p>

<p>
A rover's position is represented by a combination of an x and y
co-ordinate and a letter representing one of the four cardinal compass
points. An example position on the grid might be [0,0,N] which means
the rover is in the bottom left corner and facing North. Assume that
the square directly North from (x, y) is (x, y+1).
<p>

<p>
The input to the rover is via two functions:
<br/><br/>
1. position(x, y, h) deploys the rover to an initial grid location [x,y,h].
<br/><br/>
2. move(s) accepts a command string of the form "L1R2". L spins the
rover 90 degrees left, R spins the rover 90 degrees right and a number
moves the rover by the appropriate number of grid points in the
direction it's currently facing. The command string can be of any
reasonable length.
</p>

<p>
Test your program by starting in an initial position [10,10,N] and
then issuing the command "R1R3L2L1". The output from the program should
be the final grid location and heading of the rover.
</p>
</div>

<p>
I encourage you to write your own solution but here's my attempt.
</p>

<pre>
W = 0 S = 1 E = 2 N = 3
dirs = ['W', 'S', 'E', 'N']

position = fn (x, y, h) [x, y, h] end
print = fn (x:y:h:_) show([x, y, dirs!h]) end

move = fn (r, s)
    foldl(transform, r, s)
    where transform = fn (x:y:h:_, c)
              if c == 'L' then [x, y, (h + 1) mod 4]
              else if c == 'R' then [x, y, rotr(h) - 1]
              else translate(x, y, h, c - '0')
          end
          rotr = fn (h) if h == 0 then 4 else h end
          translate = fn (x, y, h, c)
              if even(h) then [x + ((h - 1) * c), y, h]
              else [x, y + ((h - 2) * c), h]
          end
end

print(move(position(10, 10, N), "R1R3L2L1"))
</pre>

<h2>Where next?</h2>

<p>
You've now learnt many of the foundations of functional
programming. The next step is to learn to "think functionally" and a
good way of doing this is to pick simple programs and try to write
them without side effects. You can of course continue to use Primer
for this but you'll soon want to move on to something more powerful
such as <a href="http://haskell.org/">Haskell</a> or
<a href="http://clojure.org/">Clojure</a>.  
</p>

<p>
Whichever language you choose I hope Primer has proved to
be a useful introduction to functional programming and I'd like to
hear your comments and suggestions for improvements.
</p>

<h2>Thanks...</h2>

<p>
Michael Ben-Yosef has provided invaluable input into the design of
both the language and the tutorial. His ability to debug Primer code
without a working copy of the interpreter is quite extraordinary!
</p>

<p>
Damon Dolby has tested several releases of the code and tolerated numerous
incompatible changes to the language syntax.
</p>

<hr/>
&copy; 2010 <a href="mailto:philip.armitage@gmail.com">Phil Armitage</a>
</div>
</body>
</html>
